<?php

namespace Tests\Unit\Commands\Ngrok;

use App\Models\Setting;
use App\Models\Site;
use App\PorterLibrary;
use App\Support\Console\Cli;
use App\Support\Console\DockerCompose\CliCommand;
use App\Support\Console\DockerCompose\NullCliCommand;
use App\Support\Mechanics\Mechanic;
use Mockery;
use Tests\BaseTestCase;
use Tests\Unit\Support\Concerns\MocksDockerCompose;

class OpenTest extends BaseTestCase
{
    use MocksDockerCompose;

    public function remakePorter()
    {
        $this->mockDockerCompose();

        parent::remakePorter();
    }

    /** @test */
    public function it_checks_if_the_site_exists()
    {
        Setting::updateOrCreate('home', __DIR__);

        $this->dockerCompose->shouldNotReceive('runContainer');

        $this->artisan('ngrok', ['doesntexist']);
    }

    /** @test */
    public function it_checks_that_the_alternative_loopback_is_being_used()
    {
        Setting::updateOrCreate('home', __DIR__);
        $site = factory(Site::class)->create();

        $this->mockUsingStandardLoopback();

        $this->dockerCompose->shouldNotReceive('runContainer');

        $this->artisan('ngrok', ['site' => $site->name]);
    }

    /** @test */
    public function it_will_remove_ssl_and_replace_it()
    {
        Setting::updateOrCreate('home', __DIR__);
        $site = factory(Site::class)->create(['secure' => true]);

        $this->mockUsingAlternativeLoopback();

        $this->dockerCompose
            // We are not bothered about all the functionality being passed through DockerCompose.
            // So here we build a null command for all the other calls, this doesn't actually call DockerCompose.
            ->shouldIgnoreMissing(new NullCliCommand(app(Cli::class), 'ps'))

            // Here we check that we do try to run a container, and when doing so, we want secure to be false.
            ->shouldReceive('runContainer')
            ->withArgs(function () use ($site) {
                $this->assertSame(false, $site->fresh()->secure);

                return true;
            })
            ->once()
            ->andReturnSelf();

        $this->artisan('ngrok', ['site' => $site->name]);
        $this->assertSame(true, $site->secure);
    }

    /** @test */
    public function it_will_run_ngrok()
    {
        Setting::updateOrCreate('home', __DIR__);
        $site = factory(Site::class)->create(['secure' => false]);

        $this->mockUsingAlternativeLoopback();

        // Check that the `stop ngrok` command is being run *before* the container run
        $this->dockerCompose->shouldReceive('command')->with('stop ngrok')
            ->andReturn($this->getNgrokStopCommandMock())->once()->ordered();

        // Check that the ngrok container is being run
        $this->dockerCompose
            // We are not bothered about all the functionality being passed through DockerCompose.
            // So here we build a null command for all the other calls, this doesn't actually call DockerCompose.
            ->shouldIgnoreMissing(new NullCliCommand(app(Cli::class), 'ps'))
            ->shouldReceive('runContainer')
            ->with('ngrok')
            ->once()
            ->andReturn($command = \Mockery::mock(CliCommand::class))
            ->ordered();

        $command->shouldReceive('append')
            ->with("ngrok http -host-header=rewrite -region=eu -bind-tls=false -inspect=true {$site->url}:80")
            ->andReturnSelf()
            ->once();
        $command->shouldReceive('interactive')->withNoArgs()->andReturnSelf()->once();
        $command->shouldReceive('perform')->withNoArgs()->once();

        // Check that the `stop ngrok` command is being run *after* the container run
        $this->dockerCompose->shouldReceive('command')->with('stop ngrok')
            ->andReturn($this->getNgrokStopCommandMock())->once()->ordered();

        // Execute the command under test
        $this->artisan('ngrok', ['site' => $site->name]);
    }

    /**
     * Get the mock for the `stop ngrok` CLI command.
     *
     * @return Mockery\MockInterface
     */
    private function getNgrokStopCommandMock()
    {
        $stopCommand = \Mockery::mock(CliCommand::class);
        $stopCommand->shouldReceive('realTime')->withNoArgs()->andReturnSelf()->once();
        $stopCommand->shouldReceive('perform')->withNoArgs()->once();

        return $stopCommand;
    }

    protected function mockUsingAlternativeLoopback()
    {
        $mechanicMock = Mockery::mock(Mechanic::class);
        $mechanicMock
            ->shouldIgnoreMissing()
            ->shouldReceive('isUsingStandardLoopback')->withNoArgs()->andReturn(false)->once();

        $this->app->instance(Mechanic::class, $mechanicMock);
        $this->app->get(PorterLibrary::class)->setMechanic($mechanicMock);
    }

    protected function mockUsingStandardLoopback()
    {
        $mechanicMock = Mockery::mock(Mechanic::class);
        $mechanicMock
            ->shouldIgnoreMissing()
            ->shouldReceive('isUsingStandardLoopback')->withNoArgs()->andReturn(true)->once();

        $this->app->instance(Mechanic::class, $mechanicMock);
        $this->app->get(PorterLibrary::class)->setMechanic($mechanicMock);
    }
}
